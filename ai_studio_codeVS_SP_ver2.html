<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>THE DECKS - Refined Rules Edition</title>
    <style>
        /* スタイルは以前のものを継承 */
        body { font-family: sans-serif; background: #2c3e50; color: white; display: flex; flex-direction: column; align-items: center; margin: 0; padding-bottom: 20px;}
        #game-board { width: 1000px; display: flex; flex-direction: column; gap: 10px; margin-top: 20px;}
        .player-area { border: 2px solid #7f8c8d; padding: 10px; border-radius: 10px; background: #34495e; position: relative; transition: all 0.3s; }
        .active-area { border-color: #f1c40f; box-shadow: 0 0 20px rgba(241, 196, 15, 0.4); }
        .stats { display: flex; justify-content: space-around; font-weight: bold; margin-bottom: 5px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px;}
        .active-styles-display { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 8px; justify-content: center; min-height: 24px; }
        .style-chip { background: #f1c40f; color: #000; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; cursor: help; border: 1px solid #d4ac0d; }
        .field, .hand { display: flex; gap: 10px; min-height: 120px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; margin-top: 5px; align-items: center; justify-content: center;}
        .card { width: 65px; height: 95px; background: white; color: black; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; font-weight: bold; border: 3px solid transparent; user-select: none; transition: all 0.2s; position: relative; }
        .card.red { color: #e74c3c; }
        .card.colorless { background: #ecf0f1; color: #2c3e50; border: 2px double #7f8c8d; }
        .card.back { background: #2980b9 !important; border-color: #3498db; }
        .card.tapped { transform: rotate(15deg); opacity: 0.7; background: #bdc3c7; }
        .card.selected { border-color: #3498db; transform: translateY(-10px); box-shadow: 0 5px 15px rgba(52, 152, 219, 0.6); z-index: 10; }
        .card.spell-main { border-color: #9b59b6; box-shadow: 0 0 15px #9b59b6; }
        .card.can-target { border-color: #e67e22; animation: blink 0.8s infinite; }
        @keyframes blink { 0% { box-shadow: 0 0 5px #e67e22; } 50% { box-shadow: 0 0 20px #e67e22; } 100% { box-shadow: 0 0 5px #e67e22; } }
        .suit { font-size: 24px; }
        .controls { margin: 15px; display: flex; gap: 10px; background: #1a252f; padding: 15px; border-radius: 10px; width: 980px; justify-content: center;}
        .log-container { width: 1000px; height: 180px; background: #000; border: 2px solid #7f8c8d; border-radius: 5px; overflow-y: scroll; padding: 10px; box-sizing: border-box; }
        .log-entry { margin-bottom: 4px; font-family: monospace; font-size: 12px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-user { color: #00d2ff; }
        .log-ai { color: #ff9f43; }
        .log-system { color: #00ff00; font-weight: bold; }
        .log-combat { color: #ee5253; }
        button { padding: 10px 15px; cursor: pointer; font-weight: bold; border-radius: 5px; border: none; background: #ecf0f1; transition: all 0.2s; }
        button:hover { background: #bdc3c7; }
        button.primary { background: #f1c40f; color: #000; }
        button.active-mode { background: #f1c40f !important; color: #000 !important; box-shadow: 0 0 12px #f1c40f; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 200; flex-direction: column; align-items: center; justify-content: center; }
        .modal-content { background: #34495e; padding: 25px; border-radius: 10px; text-align: center; border: 2px solid #f1c40f; width: 600px; max-height: 90vh; overflow-y: auto;}
        .style-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
        .style-option { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; display: flex; align-items: center; font-size: 11px; text-align: left;}
        .style-name { color: #f1c40f; font-weight: bold; margin-right: 5px;}
        .style-sp { background: #f1c40f; color: #000; padding: 1px 4px; border-radius: 3px; font-size: 10px; margin-right: 10px;}
        .direct-attack-btn { background: #e74c3c; color: white; padding: 10px 20px; border-radius: 5px; border: 2px solid white; cursor: pointer; font-weight: bold; display: none; }
    </style>
</head>
<body>

<h1>THE DECKS</h1>
<div id="mode-text" style="color:#f1c40f; font-weight:bold; margin-bottom: 5px; height: 20px;"></div>

<!-- 初期モード選択 -->
<div id="start-modal" class="modal" style="display: flex;">
    <div class="modal-content">
        <h2>対戦開始</h2>
        <p>ルールモードを選択してください</p>
        <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px;">
            <button class="primary" style="padding: 20px 40px;" onclick="chooseMode('basic')">基本ルールのみ</button>
            <button class="primary" style="padding: 20px 40px;" onclick="chooseMode('style')">採用型ルールあり</button>
        </div>
    </div>
</div>

<!-- スタイル選択モーダル -->
<div id="setup-modal" class="modal">
    <div class="modal-content">
        <h2>スタイル選択 (残りSP: <span id="remaining-sp">4</span>)</h2>
        <div class="style-grid" id="style-list"></div>
        <button class="primary" onclick="startGameWithStyles()">試合開始</button>
    </div>
</div>

<div id="game-board" style="visibility: hidden;">
    <div id="p2-area" class="player-area">
        <div class="stats">AI | Deck: <span id="p2-deck">0</span> | AP: <span id="p2-ap">0</span> | Trash: <span id="p2-trash-count">0</span></div>
        <div id="p2-styles-display" class="active-styles-display"></div>
        <div id="p2-field" class="field">
            <button id="p2-direct-btn" class="direct-attack-btn" onclick="executeDirectAttack()">直接攻撃！</button>
        </div>
        <div id="p2-hand" class="hand"></div>
    </div>
    <div id="p1-area" class="player-area">
        <div class="stats">Player 1 | Deck: <span id="p1-deck">0</span> | AP: <span id="p1-ap">0</span> | Trash: <span id="p1-trash-count">0</span></div>
        <div id="p1-styles-display" class="active-styles-display"></div>
        <div id="p1-field" class="field"></div>
        <div id="p1-hand" class="hand"></div>
    </div>
</div>

<div class="controls" style="visibility: hidden;">
    <button id="btn-SUMMON" onclick="setMode('SUMMON')">招集 (1AP)</button>
    <button id="btn-SPELL" onclick="setMode('SPELL')">スペル (1AP+コスト)</button>
    <button id="btn-ATTACK" onclick="setMode('ATTACK')">攻撃 (1AP)</button>
    <button id="btn-WITHDRAW" onclick="setMode('WITHDRAW')">撤退 (1or2AP)</button>
    <button class="primary" onclick="endTurn()">ターン終了</button>
    <button style="margin-left: 50px; background:#e74c3c; color:white;" onclick="confirmRestart()">再起動</button>
</div>

<div id="game-log" class="log-container" style="visibility: hidden;"></div>

<!-- モーダル各種 -->
<div id="joker-modal" class="modal"><div class="modal-content"><h3>JOKER属性選択</h3><button onclick="resolveJokerChoice('black')">黒(破壊)</button><button onclick="resolveJokerChoice('red')">赤(ドロー/回収)</button></div></div>
<div id="red-choice-modal" class="modal"><div class="modal-content"><h3>赤スペル選択</h3><button onclick="resolveRedSpell('DRAW')">1ドロー</button><button onclick="resolveRedSpell('RECOVER')">回収</button></div></div>
<div id="trash-modal" class="modal"><div class="modal-content"><h3>回収カード選択</h3><p style="font-size:10px">※JOKERは回収できません</p><div id="trash-selection-list"></div><button onclick="closeModal('trash-modal')">止める</button></div></div>
<div id="bounce-modal" class="modal"><div class="modal-content"><h3>ナインパンチ対象選択</h3><div id="bounce-list"></div></div></div>

<script>
const SUITS = { S: '♠', H: '♥', C: '♣', D: '♦', J: '★' };
const STYLES_DEF = [
    {id: "aceShot", name: "エースショット", rank: 1, sp: 1, desc: "A撤退時相手に3ダメ"},
    {id: "bukkumi2", name: "ぶっこみツー", rank: 2, sp: 1, desc: "2で敵撃破時AP+1"},
    {id: "spy3", name: "スパイスリー", rank: 3, sp: 1, desc: "3で攻撃時相手手札確認"},
    {id: "shield4", name: "盾の四", rank: 4, sp: 1, desc: "4がいる限り他は攻撃不可"},
    {id: "bond5", name: "5の結束", rank: 5, sp: 1, desc: "5が2体いれば数値10(JOK除)"},
    {id: "barikata6", name: "バリカタシックス", rank: 6, sp: 1, desc: "6は同色/JOK/黒スペ以外不壊"},
    {id: "lucky7", name: "ラッキーセブン", rank: 7, sp: 1, desc: "7攻撃時デッキ1回復"},
    {id: "noCost8", name: "ノーコスエイト", rank: 8, sp: 1, desc: "8スペルがコスト0"},
    {id: "punch9", name: "ナインパンチ", rank: 9, sp: 1, desc: "9招集時1APでバウンス"},
    {id: "heavy10", name: "十の重圧", rank: 10, sp: 2, desc: "敵協力戦に+1AP要求"},
    {id: "assassinJ", name: "アサシンジャック", rank: 11, sp: 1, desc: "Jの攻撃が0AP"},
    {id: "queenOrder", name: "クイーンズオーダー", rank: 12, sp: 1, desc: "Qスペル時2ダメ"},
    {id: "kingAura", name: "王の威圧", rank: 13, sp: 3, desc: "敵招集に2AP要求"},
    {id: "suitSync", name: "スート連携", rank: 0, sp: 2, desc: "4枚同スートなら数値+2(JOK除)"},
    {id: "blackCurse", name: "黒の呪い", rank: 0, sp: 3, desc: "黒スペル破壊時1ダメ(JOK除)"},
    {id: "redHeal", name: "赤の癒し", rank: 0, sp: 3, desc: "赤スペル使用時1枚回復(JOK除)"}
];

let p1, p2, turn = 1, mode = 'IDLE', selectedCards = [], spellMainCard = null;
let p1Styles = [], p2Styles = [];

function chooseMode(m) {
    document.getElementById('start-modal').style.display = 'none';
    if(m === 'basic') { p1Styles = []; p2Styles = []; startGameWithStyles(); } 
    else { renderStyleSelection(); document.getElementById('setup-modal').style.display = 'flex'; }
}

function renderStyleSelection() {
    const list = document.getElementById('style-list'); list.innerHTML = '';
    STYLES_DEF.forEach(s => {
        const div = document.createElement('div'); div.className = 'style-option';
        div.innerHTML = `<input type="checkbox" class="style-check" value="${s.id}" data-sp="${s.sp}">
                         <span class="style-sp">${s.sp}SP</span>
                         <div><div class="style-name">${s.name}</div><div style="font-size:9px">${s.desc}</div></div>`;
        list.appendChild(div);
    });
    document.querySelectorAll('.style-check').forEach(ck => {
        ck.addEventListener('change', () => {
            let total = 0; document.querySelectorAll('.style-check:checked').forEach(c => total += parseInt(c.dataset.sp));
            if(total > 4) { ck.checked = false; total -= parseInt(ck.dataset.sp); alert("SP上限は4です"); }
            document.getElementById('remaining-sp').innerText = 4 - total;
        });
    });
}

function startGameWithStyles() {
    if(p1Styles.length === 0 && document.getElementById('setup-modal').style.display === 'flex') {
        p1Styles = Array.from(document.querySelectorAll('.style-check:checked')).map(c => c.value);
        let aiSp = 0; let pool = [...STYLES_DEF].sort(() => Math.random() - 0.5);
        pool.forEach(s => { if(aiSp + s.sp <= 4) { p2Styles.push(s.id); aiSp += s.sp; } });
    }
    document.getElementById('setup-modal').style.display = 'none';
    document.getElementById('game-board').style.visibility = 'visible';
    document.querySelector('.controls').style.visibility = 'visible';
    document.getElementById('game-log').style.visibility = 'visible';
    init();
}

function init() {
    p1 = { name: "Player 1", deck: createDeck(['S', 'H']), hand: [], field: [], trash: [], ap: 0, styles: p1Styles };
    p2 = { name: "AI", deck: createDeck(['C', 'D']), hand: [], field: [], trash: [], ap: 0, styles: p2Styles };
    for(let i=0; i<3; i++) { p1.hand.push(p1.deck.pop()); p2.hand.push(p2.deck.pop()); }
    document.getElementById('game-log').innerHTML = "";
    renderStylesDisplay();
    turn = 1; log("=== GAME START ===", "system"); startTurn();
}

function createDeck(suits) {
    let d = []; suits.forEach(s => { for(let r=1; r<=13; r++) d.push({ suit: s, rank: r, red: (s==='H'||s==='D'), tapped: false }); });
    d.push({ suit: 'J', rank: 14, isJoker: true, red: null, tapped: false });
    for (let i = d.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [d[i], d[j]] = [d[j], d[i]]; }
    return d;
}

function renderStylesDisplay() {
    const render = (player, containerId) => {
        const container = document.getElementById(containerId); container.innerHTML = '';
        player.styles.forEach(id => {
            const def = STYLES_DEF.find(s => s.id === id);
            if (def) { const chip = document.createElement('span'); chip.className = 'style-chip'; chip.innerText = def.name; chip.title = def.desc; container.appendChild(chip); }
        });
    };
    render(p1, 'p1-styles-display'); render(p2, 'p2-styles-display');
}

function log(msg, type = "system") {
    const l = document.getElementById('game-log'); const entry = document.createElement('div');
    entry.className = `log-entry log-${type}`; entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
    l.insertBefore(entry, l.firstChild);
}

function getCardName(c) {
    if(!c) return "なし"; if(c.isJoker) return "[JOKER]";
    let val = c.rank; if(val===1) val='A'; else if(val===11) val='J'; else if(val===12) val='Q'; else if(val===13) val='K';
    return `[${SUITS[c.suit]}${val}]`;
}

function getEffectiveRank(card, player) {
    if (card.isJoker) return 14;
    let rank = card.rank;
    if (rank === 5 && player.styles.includes("bond5")) { if (player.field.filter(c => c.rank === 5).length >= 2) rank = 10; }
    if (player.styles.includes("suitSync") && player.field.length === 4) {
        const firstSuit = player.field[0].suit;
        if (player.field.every(c => c.suit === firstSuit && !c.isJoker)) rank += 2;
    }
    return rank;
}

function startTurn() {
    const p = (turn === 1 ? p1 : p2); log(`--- ${p.name} ターン開始 ---`, "system");
    for(let i=0; i<2; i++) { if(p.deck.length > 0) p.hand.push(p.deck.pop()); else { alert(`${p.name} 山札切れ！`); location.reload(); return; } }
    p.ap = Math.min(p.hand.length, 10); // AP上限10
    log(`${p.name}: AP ${p.ap} を獲得 (上限10)`, "system");
    p.field.forEach(c => c.tapped = false); updateUI();
    if(turn === 2) setTimeout(aiRoutine, 1000);
}

function endTurn() { 
    const p = (turn === 1 ? p1 : p2);
    log(`--- ${p.name} ターン終了 ---`, "system");
    turn = (turn === 1 ? 2 : 1); startTurn(); 
}

function confirmRestart() { if(confirm("最初からやり直しますか？")) location.reload(); }

function setMode(m) {
    if(turn !== 1) return; mode = (mode === m) ? 'IDLE' : m; selectedCards = []; spellMainCard = null;
    document.getElementById('mode-text').innerText = `モード: ${mode}`; updateUI();
}

function handleCardClick(owner, area, idx) {
    if(turn !== 1) return;
    const p = p1; const opp = p2; const card = (owner === 1 ? p1 : p2)[area][idx];

    if(mode === 'SUMMON' && owner === 1 && area === 'hand') {
        let cost = (opp.field.some(c => c.rank === 13) && opp.styles.includes("kingAura")) ? 2 : 1;
        if(p.ap < cost) return log("AP不足", "system");
        if(p.field.length >= 4) return log("盤面上限", "system");
        const summoned = p.hand.splice(idx, 1)[0]; 
        summoned.tapped = false; // アンタップでの招集徹底
        p.field.push(summoned); p.ap -= cost;
        log(`Player 1: ${getCardName(summoned)} 招集 (消費AP:${cost})`, "user");
        if(summoned.rank === 9 && p.styles.includes("punch9") && p.ap > 0 && opp.field.length > 0) showBounceModal();
        else setMode('IDLE');
    }
    else if(mode === 'SPELL' && owner === 1 && area === 'hand') {
        spellMainCard = { card, idx };
        if(card.rank === 8 && p.styles.includes("noCost8")) { log("P1: 8ノーコス発動！", "user"); startSpellEffect(); }
        else { const cost = card.isJoker ? 0 : card.rank - 1; if(cost === 0) startSpellEffect(); else mode = 'SPELL_COST'; }
    }
    else if(mode === 'SPELL_COST' && owner === 1) {
        if(area === 'hand' && idx === spellMainCard.idx) return;
        if(area === 'field' && card.tapped) return log("行動済みはコストにできません", "system");
        selectedCards.push({ area, idx, rank: card.rank, name: getCardName(card) });
        if(selectedCards.reduce((s, c) => s + c.rank, 0) >= spellMainCard.card.rank - 1) startSpellEffect();
    }
    else if(mode === 'SPELL_TARGET_BLACK' && owner === 2 && area === 'field') {
        const c = p2.field.splice(idx, 1)[0]; p2.trash.push(c);
        log(`P1: スペル破壊 -> AIの ${getCardName(c)}`, "user");
        if(p1.styles.includes("blackCurse") && !spellMainCard.card.isJoker) { log("黒の呪い発動：1ダメ", "user"); applyDamage(p2, 1); }
        finalizeSpell();
    }
    else if(mode === 'ATTACK' && owner === 1 && area === 'field') {
        if(card.tapped) return;
        if(selectedCards.length > 0 && p1.field[selectedCards[0]].red !== card.red) return log("協力戦は同色のみ", "system");
        if(selectedCards.includes(idx)) selectedCards = selectedCards.filter(i => i !== idx); else selectedCards.push(idx);
    }
    else if(mode === 'ATTACK' && owner === 2 && area === 'field') {
        if(selectedCards.length === 0) return;
        if(opp.field.some(c => c.rank === 4) && opp.styles.includes("shield4") && card.rank !== 4) return log("盾の四：4を狙え", "system");
        executeCombat(selectedCards, idx);
    }
    else if(mode === 'WITHDRAW' && owner === 1 && area === 'field') {
        let cost = card.tapped ? 2 : 1; // アンタップ1、タップ2
        if(p.ap < cost) return log(`AP不足 (撤退コスト:${cost})`, "system");
        const c = p.field.splice(idx, 1)[0]; p.deck.unshift(c); p.ap -= cost;
        log(`P1: ${getCardName(c)} 撤退 (AP消費:${cost})`, "user");
        if(c.rank === 1 && p.styles.includes("aceShot")) { log("エースショット発動：3ダメ", "user"); applyDamage(p2, 3); }
        setMode('IDLE');
    }
    updateUI();
}

function startSpellEffect() {
    const main = spellMainCard.card;
    const costNames = selectedCards.length > 0 ? ` (コスト: ${selectedCards.map(s=>s.name).join(", ")})` : "";
    log(`P1: ${getCardName(main)} 使用${costNames}`, "user");
    selectedCards.sort((a,b) => b.idx - a.idx).forEach(c => { p1.trash.push(p1[c.area].splice(c.idx, 1)[0]); });
    const mainIdx = p1.hand.indexOf(main); p1.trash.push(p1.hand.splice(mainIdx, 1)[0]); p1.ap--;
    if(main.red && p1.styles.includes("redHeal") && !main.isJoker && p1.trash.length > 0) { p1.deck.unshift(p1.trash.pop()); log("赤の癒し：回復", "user"); }
    if(main.isJoker) document.getElementById('joker-modal').style.display = 'flex';
    else if(!main.red) { if(p2.field.length > 0) mode = 'SPELL_TARGET_BLACK'; else finalizeSpell(); }
    else showRedSpellModal();
    updateUI();
}

function resolveJokerChoice(color) {
    document.getElementById('joker-modal').style.display = 'none';
    if(color === 'black') { if(p2.field.length > 0) { mode = 'SPELL_TARGET_BLACK'; updateUI(); } else finalizeSpell(); } 
    else showRedSpellModal();
}
function showRedSpellModal() { document.getElementById('red-choice-modal').style.display = 'flex'; }
function resolveRedSpell(choice) {
    document.getElementById('red-choice-modal').style.display = 'none';
    if(choice === 'DRAW') { if(p1.deck.length > 0) { p1.hand.push(p1.deck.pop()); log("P1: 1枚ドロー", "user"); } finalizeSpell(); } 
    else { if(p1.trash.filter(c=>!c.isJoker).length === 0) resolveRedSpell('DRAW'); else showTrashRecoverModal(); }
}
function showTrashRecoverModal() {
    const list = document.getElementById('trash-selection-list'); list.innerHTML = '';
    p1.trash.forEach((c, i) => {
        if(c.isJoker) return; // ジョーカー回収不可
        const el = createCardEl(c); el.onclick = () => { p1.hand.push(p1.trash.splice(i, 1)[0]); log(`P1: 墓地から ${getCardName(c)} 回収`, "user"); closeModal('trash-modal'); finalizeSpell(); };
        list.appendChild(el);
    });
    document.getElementById('trash-modal').style.display = 'flex';
}
function finalizeSpell() {
    if(spellMainCard && spellMainCard.card.rank === 12 && p1.styles.includes("queenOrder")) { log("Qオーダー：2ダメ", "user"); applyDamage(p2, 2); }
    mode = 'IDLE'; selectedCards = []; spellMainCard = null; updateUI();
}
function showBounceModal() {
    const list = document.getElementById('bounce-list'); list.innerHTML = '';
    p2.field.forEach((c, i) => {
        const btn = document.createElement('button'); btn.innerText = getCardName(c);
        btn.onclick = () => { p2.hand.push(p2.field.splice(i, 1)[0]); log(`9パンチ：AIの ${getCardName(c)} バウンス`, "user"); p1.ap--; closeModal('bounce-modal'); setMode('IDLE'); updateUI(); };
        list.appendChild(btn);
    });
    document.getElementById('bounce-modal').style.display = 'flex';
}

function executeCombat(atkIdxs, defIdx) {
    const p = p1; const opp = p2; const attackers = atkIdxs.map(i => p.field[i]); const defender = opp.field[defIdx];
    const atkNames = attackers.map(c => getCardName(c)).join("＋");
    const atkPower = attackers.reduce((s, c) => s + getEffectiveRank(c, p), 0);
    const defPower = getEffectiveRank(defender, opp);
    let apCost = (attackers.length > 1 && opp.field.some(c => c.rank === 10) && opp.styles.includes("heavy10")) ? 2 : 1;
    if(attackers.every(c => c.rank === 11) && p.styles.includes("assassinJ")) apCost = 0;
    if(p.ap < apCost) return log("AP不足", "system");
    p.ap -= apCost; attackers.forEach(c => c.tapped = true);
    log(`P1: ${atkNames} 攻撃 (${atkPower} vs ${defPower})`, "combat");
    if(attackers.some(c => c.rank === 7) && p.styles.includes("lucky7") && p.trash.length > 0) p.deck.unshift(p.trash.pop());
    if(attackers.some(c => c.rank === 3) && p.styles.includes("spy3")) log(`AI手札: ${opp.hand.map(c => getCardName(c)).join(", ")}`, "system");

    let win = false, mutual = false, youLose = false;
    if (attackers[0].isJoker || defender.isJoker) { 
        if (atkPower > defPower) win = true; else if (atkPower === defPower) { win = true; mutual = true; } 
    }
    else if (attackers[0].red !== defender.red) win = true;
    else { // 同色戦闘
        if (atkPower > defPower) win = true; 
        else if (atkPower === defPower) { win = true; mutual = true; } 
        else { youLose = true; } // 数値が下回った場合
    }

    if(win) {
        opp.trash.push(opp.field.splice(defIdx, 1)[0]);
        if(attackers[0].red === defender.red && !attackers[0].isJoker && !defender.isJoker) { log("判定: 1ダメージ", "combat"); applyDamage(opp, 1); }
        if(mutual) { log("判定: 相打ち", "combat"); atkIdxs.sort((a,b)=>b-a).forEach(i => p.trash.push(p.field.splice(i, 1)[0])); }
        if(attackers.some(c => c.rank === 2) && p.styles.includes("bukkumi2")) p.ap++;
    } else if(youLose) {
        log("判定: パワー不足で返り討ち(自分のみ破壊)", "combat");
        atkIdxs.sort((a,b)=>b-a).forEach(i => p.trash.push(p.field.splice(i, 1)[0]));
    }
    setMode('IDLE'); updateUI();
}

function executeDirectAttack() {
    const attackers = selectedCards.map(i => p1.field[i]);
    const atkNames = attackers.map(c => getCardName(c)).join("＋");
    let apCost = (attackers.every(c => c.rank === 11) && p1.styles.includes("assassinJ")) ? 0 : 1;
    if(p1.ap < apCost) return log("AP不足", "system");
    p1.ap -= apCost; selectedCards.forEach(i => p1.field[i].tapped = true);
    applyDamage(p2, 2); log(`P1: ${atkNames} 直接攻撃 -> 2ダメ`, "combat");
    setMode('IDLE'); updateUI();
}

// --- AI Routine ---
async function aiRoutine() {
    if(turn !== 2) return; const p = p2; const opp = p1; const wait = (ms) => new Promise(res => setTimeout(res, ms));
    log("AI: 戦略検討中...", "ai"); await wait(800);
    // スペル
    let bHand = p.hand.findIndex(c => !c.red && !c.isJoker);
    let eight = p.hand.findIndex(c => c.rank === 8);
    if(eight !== -1 && p.styles.includes("noCost8") && p.ap > 0) { log(`AI: 8ノーコス発動`, "ai"); await aiExecSpell(eight, true); }
    else if(bHand !== -1 && p.ap > 0 && opp.field.length > 0 && canPay(p, p.hand[bHand].rank-1, [bHand])) await aiExecSpell(bHand);
    // 招集
    while(p.ap > (opp.field.some(c=>c.rank===13)&&opp.styles.includes("kingAura")?1:0) && p.field.length < 4 && p.hand.length > 0) {
        await wait(600); p.hand.sort((a,b)=>b.rank-a.rank); let c = p.hand.shift(); c.tapped = false; p.field.push(c);
        let cost = (opp.field.some(k=>k.rank===13)&&opp.styles.includes("kingAura")?2:1); p.ap -= cost;
        log(`AI: ${getCardName(c)} 招集 (消費AP:${cost})`, "ai");
        if(c.rank === 9 && p.styles.includes("punch9") && p.ap > 0 && opp.field.length > 0) { let b = opp.field.shift(); opp.hand.push(b); p.ap--; log(`AI: 9バウンス -> ${getCardName(b)}`, "ai"); }
        updateUI();
    }
    // 攻撃
    let atks = p.field.filter(c => !c.tapped);
    for(let c of atks) {
        if(p.ap <= 0 && !(c.rank === 11 && p.styles.includes("assassinJ"))) continue;
        await wait(800);
        if(opp.field.length === 0) {
            c.tapped = true; if(!(c.rank === 11 && p.styles.includes("assassinJ"))) p.ap--;
            log(`AI: 直接攻撃 (AP消費:${(c.rank===11&&p.styles.includes("assassinJ")?0:1)})`, "combat"); applyDamage(opp, 2);
        } else {
            let targetIdx = opp.field.findIndex(f => f.rank === 4 && opp.styles.includes("shield4")); if(targetIdx === -1) targetIdx = 0;
            let def = opp.field[targetIdx];
            if(c.red !== def.red || getEffectiveRank(c, p) >= getEffectiveRank(def, opp)) {
                c.tapped = true; if(!(c.rank === 11 && p.styles.includes("assassinJ"))) p.ap--;
                log(`AI: ${getCardName(c)} 攻撃 -> ${getCardName(def)}`, "combat");
                if(c.red === def.red && getEffectiveRank(c,p) < getEffectiveRank(def,opp)) {
                    log("AI: パワー負けにつきAIのみ破壊", "combat"); p.trash.push(p.field.splice(p.field.indexOf(c),1)[0]);
                } else {
                    opp.field.splice(targetIdx, 1); opp.trash.push(def);
                    if(c.red === def.red && !c.isJoker) { log("AI: 1ダメージ", "combat"); applyDamage(opp, 1); }
                    if(getEffectiveRank(c,p) === getEffectiveRank(def,opp)) { log("AI: 相打ち破壊", "combat"); p.trash.push(p.field.splice(p.field.indexOf(c),1)[0]); }
                }
                if(c.rank === 2 && p.styles.includes("bukkumi2")) p.ap++;
            }
        }
        updateUI();
    }
    await wait(600); endTurn();
}

function canPay(p, req, ignore) { let v = 0; p.hand.forEach((c,i) => { if(!ignore.includes(i)) v += c.rank; }); p.field.forEach(c => { if(!c.tapped) v += c.rank; }); return v >= req; }
async function aiExecSpell(idx, free = false) {
    const p = p2; const opp = p1; const card = p.hand[idx]; const req = free ? 0 : card.rank - 1;
    let costLog = [];
    if(req > 0) {
        let cand = []; p.hand.forEach((c,i) => { if(i!==idx) cand.push({c, a:'hand'}); }); p.field.forEach(c => { if(!c.tapped) cand.push({c, a:'field'}); });
        cand.sort((a,b) => b.c.rank - a.c.rank); let paid = 0;
        for(let o of cand) { if(paid >= req) break; let arr = (o.a === 'hand' ? p.hand : p.field); let target = arr.splice(arr.indexOf(o.c), 1)[0]; p.trash.push(target); paid += o.c.rank; costLog.push(getCardName(target)); }
    }
    p.hand.splice(p.hand.indexOf(card), 1); p.trash.push(card); p.ap--;
    log(`AI: ${getCardName(card)} スペル発動${costLog.length>0 ? " (コスト:"+costLog.join(",")+")" : ""}`, "ai");
    if(card.red && p.styles.includes("redHeal") && !card.isJoker && p.trash.length > 0) p.deck.unshift(p.trash.pop());
    if(!card.red) { let d = opp.field.shift(); opp.trash.push(d); log(`AI: ${getCardName(d)} 破壊`, "ai"); if(p.styles.includes("blackCurse")) applyDamage(opp, 1); }
    else { p.hand.push(p.deck.pop()); log("AI: 1枚ドロー", "ai"); }
    if(card.rank === 12 && p.styles.includes("queenOrder")) applyDamage(opp, 2);
    updateUI();
}

function applyDamage(target, amt) { for(let i=0; i<amt; i++) if(target.deck.length > 0) target.hand.push(target.deck.pop()); }
function closeModal(id) { document.getElementById(id).style.display = 'none'; }
function updateUI() {
    renderPlayer(1, p1); renderPlayer(2, p2);
    const modes = ['SUMMON', 'SPELL', 'ATTACK', 'WITHDRAW'];
    modes.forEach(m => { const btn = document.getElementById(`btn-${m}`); if (mode === m || (m === 'SPELL' && mode === 'SPELL_COST')) btn.classList.add('active-mode'); else btn.classList.remove('active-mode'); });
    const daBtn = document.getElementById('p2-direct-btn'); daBtn.style.display = (mode === 'ATTACK' && selectedCards.length > 0 && p2.field.length === 0) ? 'block' : 'none';
}
function renderPlayer(num, p) {
    document.getElementById(`p${num}-deck`).innerText = p.deck.length; document.getElementById(`p${num}-ap`).innerText = p.ap; document.getElementById(`p${num}-trash-count`).innerText = p.trash.length;
    const h = document.getElementById(`p${num}-hand`); h.innerHTML = '';
    p.hand.forEach((c, i) => { const el = createCardEl(c, num === 2); if(turn === 1 && num === 1) { if(spellMainCard && spellMainCard.idx === i) el.classList.add('spell-main'); if(mode === 'SPELL_COST' && selectedCards.some(s => s.area === 'hand' && s.idx === i)) el.classList.add('selected'); el.onclick = () => handleCardClick(num, 'hand', i); } h.appendChild(el); });
    const f = document.getElementById(`p${num}-field`); const daBtn = f.querySelector('.direct-attack-btn'); f.innerHTML = ''; if(daBtn) f.appendChild(daBtn);
    p.field.forEach((c, i) => { const el = createCardUI(c, p); if(c.tapped) el.classList.add('tapped'); if(turn === 1) { if(num === 1 && (mode === 'ATTACK' || mode === 'WITHDRAW') && selectedCards.includes(i)) el.classList.add('selected'); if(num === 1 && mode === 'SPELL_COST' && selectedCards.some(s => s.area === 'field' && s.idx === i)) el.classList.add('selected'); if(num === 2 && (mode === 'ATTACK' || mode === 'SPELL_TARGET_BLACK')) el.classList.add('can-target'); el.onclick = () => handleCardClick(num, 'field', i); } f.appendChild(el); });
}
function createCardEl(c, isBack) { const div = document.createElement('div'); if(isBack) { div.className = 'card back'; return div; } div.className = 'card' + (c.red === true ? ' red' : '') + (c.isJoker ? ' colorless' : ''); let val = c.isJoker ? 'JOK' : (c.rank === 1 ? 'A' : (c.rank === 11 ? 'J' : (c.rank === 12 ? 'Q' : (c.rank === 13 ? 'K' : c.rank)))); div.innerHTML = `<div class="suit">${SUITS[c.suit]}</div><div>${val}</div>`; return div; }
function createCardUI(c, player) { const div = document.createElement('div'); div.className = 'card' + (c.red === true ? ' red' : '') + (c.isJoker ? ' colorless' : ''); let rank = getEffectiveRank(c, player); let val = c.isJoker ? 'JOK' : (rank === 1 ? 'A' : (rank === 11 ? 'J' : (rank === 12 ? 'Q' : (rank === 13 ? 'K' : rank)))); div.innerHTML = `<div class="suit">${SUITS[c.suit]}</div><div>${val}</div>`; return div; }
</script>
</body>
</html>